<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Talking Tree - Control Panel</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: Arial, sans-serif;
      background-color: #f5f5f5;
      color: #333;
      position: relative;
    }
    
    h1 {
      text-align: center;
      color: #2c8c2c;
      margin-bottom: 30px;
    }
    
    .header-status {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      padding: 5px 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .main-container {
      display: flex;
      flex-direction: row;
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      border-radius: 10px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }
    
    .left-column {
      flex: 1;
      margin-right: 20px;
    }
    
    .right-column {
      width: 450px;
      position: sticky;
      top: 20px;
      align-self: flex-start;
    }
    
    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding: 10px;
      background-color: #f0f0f0;
      border-radius: 5px;
    }
    
    .connection-status {
      display: flex;
      align-items: center;
    }
    
    .status-indicator {
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background-color: #ccc;
      margin-right: 10px;
    }
    
    .status-connected {
      background-color: #4CAF50;
    }
    
    .control-section {
      margin-bottom: 30px;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 15px;
    }
    
    .section-title {
      font-weight: bold;
      margin-bottom: 15px;
      color: #2c8c2c;
    }
    
    .eye-control {
      display: flex;
      gap: 20px;
    }
    
    .eye-pad {
      width: 200px;
      height: 200px;
      background-color: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 5px;
      position: relative;
      cursor: crosshair;
    }
    
    .eye-cursor {
      width: 10px;
      height: 10px;
      background-color: #333;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .buttons {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    
    button {
      padding: 8px 15px;
      background-color: #2c8c2c;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    button:hover {
      background-color: #1f6f1f;
    }
    
    button:disabled {
      background-color: #aaa;
      cursor: not-allowed;
    }
    
    .speech-control {
      display: flex;
      flex-direction: column;
    }
    
    textarea {
      width: 100%;
      height: 100px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      resize: vertical;
      margin-bottom: 10px;
      font-family: inherit;
    }
    
    .quick-phrases {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 15px;
    }
    
    .quick-phrase {
      background-color: #eef5ee;
      border: 1px solid #c5d8c5;
      border-radius: 15px;
      padding: 5px 12px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .quick-phrase:hover {
      background-color: #d5e8d5;
    }
    
    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .manual-link {
      text-align: center;
      margin-top: 20px;
    }
    
    .manual-link a {
      color: #2c8c2c;
      text-decoration: none;
    }
    
    .manual-link a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <h1>ðŸŒ³ Talking Tree Control Panel ðŸŒ³</h1>
  
  <div class="header-status">
    <div class="connection-status">
      <div class="status-indicator" id="connectionStatus"></div>
      <span id="statusText">Disconnected</span>
    </div>
  </div>
  
  <div class="main-container">
    <div class="left-column">
      
      <div class="control-section">
        <div class="section-title">Eye Control</div>
        <div class="eye-control">
          <div class="eye-pad" id="eyePad">
            <div class="eye-cursor" id="eyeCursor"></div>
          </div>
          <div class="eye-actions">
            <p>Click and drag on the pad to move the tree's eyes.</p>
            <div class="buttons">
              <button id="blinkBtn">Blink</button>
              <button id="toggleAutoBlinkBtn" style="background-color: #607d8b;">Auto-Blink On</button>
              <button id="closeEyesBtn" style="background-color: #795548;">Close Eyes</button>
              <button id="lookAroundBtn">Look Around (Auto)</button>
            </div>
            <div class="buttons" style="margin-top: 15px;">
              <button id="toggleMagicBtn" style="background-color: #9c27b0;">âœ¨ Magic Glimmer</button>
            </div>
          </div>
        </div>
      </div>
      
      <div class="control-section">
        <div class="section-title">Speech Control</div>
        <div class="speech-control">
          <textarea id="speechText" placeholder="Type what you want the tree to say..."></textarea>
          <div class="controls">
            <div class="buttons">
              <button id="speakBtn">Speak</button>
              <button id="stopBtn">Stop</button>
            </div>
          </div>
          
          <div class="quick-phrases">
            <div class="section-title">Quick Phrases:</div>
            <div id="phrasesContainer">
              <span class="quick-phrase">Hello there!</span>
              <span class="quick-phrase">Welcome to Game Land!</span>
              <span class="quick-phrase">I'm a talking tree!</span>
              <span class="quick-phrase">How are you today?</span>
            </div>
          </div>
        </div>
      </div>
      
      <div class="control-section">
        <div class="section-title">Gate Control</div>
        <div style="display: flex; justify-content: center; gap: 20px; margin-top: 10px; flex-wrap: wrap;">
          <button id="toggleGateBtn" style="background-color: #ff9800; padding: 12px 25px; font-size: 16px;">Open Gate 1</button>
          <button id="toggleGate2Btn" style="background-color: #2196F3; padding: 12px 25px; font-size: 16px;">Open Gate 2</button>
        </div>
      </div>
    </div>

    <div class="right-column">
      <div class="control-section">
        <div class="section-title">Live View</div>
        <div class="webcam-container" style="width: 100%; position: relative;">
          <img id="webcamDisplay" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Webcam feed" style="width: 100%; border-radius: 5px; border: 1px solid #ddd;">
          <div id="webcamOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; background-color: rgba(0,0,0,0.7); color: white; border-radius: 5px;">
            Waiting for webcam feed...
          </div>
        </div>
        <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 10px;">
          <div class="buttons">
            <button id="toggleWebcamBtn">Start Feed</button>
            <button id="refreshWebcamBtn">Refresh Feed</button>
          </div>
          <div id="webcamStatus" style="font-size: 0.9rem; color: #666;">
            Not connected
          </div>
        </div>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // DOM elements
    const connectionStatus = document.getElementById('connectionStatus');
    const statusText = document.getElementById('statusText');
    const eyePad = document.getElementById('eyePad');
    const eyeCursor = document.getElementById('eyeCursor');
    const blinkBtn = document.getElementById('blinkBtn');
    const toggleAutoBlinkBtn = document.getElementById('toggleAutoBlinkBtn');
    const closeEyesBtn = document.getElementById('closeEyesBtn');
    const lookAroundBtn = document.getElementById('lookAroundBtn');
    const speechText = document.getElementById('speechText');
    const speakBtn = document.getElementById('speakBtn');
    const stopBtn = document.getElementById('stopBtn');
    // No longer using the useAI checkbox
    const phrasesContainer = document.getElementById('phrasesContainer');
    
    // Webcam elements
    const webcamDisplay = document.getElementById('webcamDisplay');
    const webcamOverlay = document.getElementById('webcamOverlay');
    const webcamStatus = document.getElementById('webcamStatus');
    const refreshWebcamBtn = document.getElementById('refreshWebcamBtn');
    const toggleWebcamBtn = document.getElementById('toggleWebcamBtn');
    const toggleMagicBtn = document.getElementById('toggleMagicBtn');
    const toggleGateBtn = document.getElementById('toggleGateBtn');
    const toggleGate2Btn = document.getElementById('toggleGate2Btn');
    
    let socket;
    let isLookingAround = false;
    let lookAroundInterval;
    let lastFrameTimestamp = 0;
    let webcamActive = false;
    let webcamStreamingEnabled = false;
    let magicGlimmerEnabled = false;
    let autoBlinkEnabled = true;
    let gateOpen = false;
    let gate2Open = false;
    
    // Disable webcam toggle button initially until we know webcam is available
    // document.addEventListener('DOMContentLoaded', () => {
    //   toggleWebcamBtn.disabled = true;
    // });
    
    // Connect to Socket.IO server
    function connectSocket() {
      // Get the current page URL to handle connecting from different devices
      const protocol = window.location.protocol === 'https:' ? 'https:' : 'http:';
      const host = window.location.hostname;
      const port = window.location.port ? `:${window.location.port}` : '';
      const serverUrl = `${protocol}//${host}${port}`;
      
      console.log(`Connecting to Socket.IO server at: ${serverUrl}`);
      
      // Connect with explicit URL and options
      socket = io(serverUrl, {
        transports: ['websocket', 'polling'],
        reconnectionAttempts: 5,
        reconnectionDelay: 1000,
        timeout: 20000
      });

      // Connection established
      socket.on('connect', () => {
        console.log('Connected to server with ID:', socket.id);
        connectionStatus.classList.add('status-connected');
        statusText.textContent = 'Connected';
        
        // Send a test message to verify connection is working
        socket.emit('test-message', { client: 'control', timestamp: Date.now() });
      });

      // Connection lost
      socket.on('disconnect', () => {
        console.log('Disconnected from server');
        connectionStatus.classList.remove('status-connected');
        statusText.textContent = 'Disconnected';
      });
      
      // Connection error
      socket.on('connect_error', (error) => {
        console.error('Connection error:', error);
        connectionStatus.classList.remove('status-connected');
        statusText.textContent = 'Connection Error';
      });
      
      // Command confirmation
      socket.on('command-received', (data) => {
        console.log('Command confirmation received:', data);
      });
      
      // Add a pinger to keep connection alive
      setInterval(() => {
        if (socket.connected) {
          socket.emit('ping', { timestamp: Date.now() });
        }
      }, 30000);
      
      // Tree status updates
      socket.on('tree-status', (data) => {
        console.log('Received tree-status event:', data);
        
        // If we get a webcam status, update the toggle button
        if (data && data.webcamReady) {
          // Webcam is initialized but not streaming
          toggleWebcamBtn.disabled = false;
          
          // If we're currently streaming, show "Stop" text, otherwise show "Start"
          if (webcamStreamingEnabled) {
            toggleWebcamBtn.textContent = 'Stop Feed';
          } else {
            toggleWebcamBtn.textContent = 'Start Feed';
          }
        }
      });
      
      // Webcam frame received
      socket.on('webcam-frame', (data) => {
        console.log('Received webcam-frame event:', data ? 'Data present' : 'No data', 
                  data?.frame ? `Frame length: ${data.frame.length}` : 'No frame');
        
        if (!data || !data.frame) {
          console.error('Invalid webcam frame data received');
          return;
        }
        
        // Update the webcam display with the received frame
        webcamDisplay.src = data.frame;
        console.log('Updated webcam display with new frame');
        
        // Show the image and hide the overlay if this is the first frame
        if (!webcamActive) {
          webcamActive = true;
          webcamOverlay.style.display = 'none';
          webcamStatus.textContent = 'Connected';
          webcamStatus.style.color = '#4CAF50';
          console.log('Webcam display activated');
          
          // Update the button state since we're receiving frames
          webcamStreamingEnabled = true;
          toggleWebcamBtn.textContent = 'Stop Feed';
        }
        
        // Update timestamp to track frame freshness
        lastFrameTimestamp = data.timestamp || Date.now();
      });
    }
    
    // No longer using the tree view button
    
    // Eye control pad
    eyePad.addEventListener('mousedown', startEyeControl);
    eyePad.addEventListener('mousemove', moveEyes);
    eyePad.addEventListener('mouseup', stopEyeControl);
    eyePad.addEventListener('mouseleave', stopEyeControl);
    
    let isControllingEyes = false;
    
    function startEyeControl(e) {
      isControllingEyes = true;
      updateEyePosition(e);
    }
    
    function moveEyes(e) {
      if (isControllingEyes) {
        updateEyePosition(e);
      }
    }
    
    function stopEyeControl() {
      isControllingEyes = false;
    }
    
    function updateEyePosition(e) {
      const rect = eyePad.getBoundingClientRect();
      const x = Math.max(0, Math.min(100, ((e.clientX - rect.left) / rect.width) * 100));
      const y = Math.max(0, Math.min(100, ((e.clientY - rect.top) / rect.height) * 100));
      
      // Update cursor position
      eyeCursor.style.left = `${x}%`;
      eyeCursor.style.top = `${y}%`;
      
      // Send command to server
      if (socket && socket.connected) {
        socket.emit('tree-command', {
          type: 'eyePosition',
          x: x,
          y: y
        });
      }
    }
    
    // Blink button
    blinkBtn.addEventListener('click', () => {
      if (socket && socket.connected) {
        socket.emit('tree-command', {
          type: 'blink'
        });
      }
    });
    
    // Toggle Auto-Blink button
    toggleAutoBlinkBtn.addEventListener('click', () => {
      autoBlinkEnabled = !autoBlinkEnabled;
      
      // Update button text and color
      if (autoBlinkEnabled) {
        toggleAutoBlinkBtn.textContent = 'Auto-Blink On';
        toggleAutoBlinkBtn.style.backgroundColor = '#607d8b';
      } else {
        toggleAutoBlinkBtn.textContent = 'Auto-Blink Off';
        toggleAutoBlinkBtn.style.backgroundColor = '#9e9e9e';
      }
      
      // Send command to tree
      if (socket && socket.connected) {
        socket.emit('tree-command', {
          type: 'toggleAutoBlink',
          enabled: autoBlinkEnabled
        });
      }
    });
    
    // Close/Open Eyes button
    let eyesClosed = false;
    closeEyesBtn.addEventListener('click', () => {
      if (socket && socket.connected) {
        eyesClosed = !eyesClosed;
        
        // Update button text
        if (eyesClosed) {
          closeEyesBtn.textContent = 'Open Eyes';
          
          // If eyes are closed, auto-blink should be disabled
          if (autoBlinkEnabled) {
            autoBlinkEnabled = false;
            toggleAutoBlinkBtn.textContent = 'Auto-Blink Off';
            toggleAutoBlinkBtn.style.backgroundColor = '#9e9e9e';
            
            // Send command to disable auto-blink
            socket.emit('tree-command', {
              type: 'toggleAutoBlink',
              enabled: false
            });
          }
        } else {
          closeEyesBtn.textContent = 'Close Eyes';
        }
        
        // Send the appropriate command
        socket.emit('tree-command', {
          type: eyesClosed ? 'closeEyes' : 'openEyes'
        });
      }
    });
    
    // Auto look around
    lookAroundBtn.addEventListener('click', toggleLookAround);
    
    function toggleLookAround() {
      isLookingAround = !isLookingAround;
      
      if (isLookingAround) {
        lookAroundBtn.textContent = 'Stop Auto Look';
        lookAroundInterval = setInterval(() => {
          const randomX = Math.random() * 100;
          const randomY = Math.random() * 100;
          
          // Update cursor position
          eyeCursor.style.left = `${randomX}%`;
          eyeCursor.style.top = `${randomY}%`;
          
          // Send command to server
          if (socket && socket.connected) {
            socket.emit('tree-command', {
              type: 'eyePosition',
              x: randomX,
              y: randomY
            });
          }
          
          // Occasionally blink
          if (Math.random() < 0.3) {
            setTimeout(() => {
              if (socket && socket.connected) {
                socket.emit('tree-command', {
                  type: 'blink'
                });
              }
            }, 500);
          }
        }, 2000);
      } else {
        lookAroundBtn.textContent = 'Look Around (Auto)';
        clearInterval(lookAroundInterval);
      }
    }
    
    // Speak button - speaks exactly what's typed without AI processing
    speakBtn.addEventListener('click', () => {
      const text = speechText.value.trim();
      if (text && socket && socket.connected) {
        speakBtn.disabled = true;
        speakBtn.textContent = 'Speaking...';
        
        // Send the text directly to the tree without any processing
        socket.emit('tree-command', {
          type: 'speak',
          text: text
        });
        
        // Re-enable button after a short delay
        setTimeout(() => {
          speakBtn.disabled = false;
          speakBtn.textContent = 'Speak';
        }, 500);
      }
    });
    
    // Stop button
    stopBtn.addEventListener('click', () => {
      if (socket && socket.connected) {
        socket.emit('tree-command', {
          type: 'stopSpeaking'
        });
      }
    });
    
    // Quick phrases
    const quickPhrases = document.querySelectorAll('.quick-phrase');
    quickPhrases.forEach(phrase => {
      phrase.addEventListener('click', () => {
        speechText.value = phrase.textContent;
      });
    });
    
    // Magic glimmer toggle
    toggleMagicBtn.addEventListener('click', () => {
      if (socket && socket.connected) {
        magicGlimmerEnabled = !magicGlimmerEnabled;
        
        // Update button state
        if (magicGlimmerEnabled) {
          toggleMagicBtn.style.backgroundColor = '#673ab7';
          toggleMagicBtn.innerHTML = 'âœ¨ Magic On';
        } else {
          toggleMagicBtn.style.backgroundColor = '#9c27b0';
          toggleMagicBtn.innerHTML = 'âœ¨ Magic Glimmer';
        }
        
        // Send command to toggle magic glimmer
        socket.emit('tree-command', {
          type: 'toggleMagic',
          enabled: magicGlimmerEnabled
        });
      }
    });
    
    // Toggle webcam button
    toggleWebcamBtn.addEventListener('click', () => {
      if (socket && socket.connected) {
        webcamStreamingEnabled = !webcamStreamingEnabled;
        
        if (webcamStreamingEnabled) {
          // Start webcam streaming
          toggleWebcamBtn.textContent = 'Stop Feed';
          webcamOverlay.style.display = 'flex';
          webcamOverlay.textContent = 'Starting webcam feed...';
          webcamStatus.textContent = 'Starting...';
          webcamStatus.style.color = '#666';
          
          // Send command to start webcam
          socket.emit('tree-command', {
            type: 'webcam-control',
            action: 'start'
          });
          
          // Request a frame right away
          socket.emit('tree-command', {
            type: 'webcam-refresh'
          });
          
          // Set a timeout to check if we received a frame
          setTimeout(() => {
            if (!webcamActive) {
              webcamOverlay.textContent = 'Webcam feed unavailable';
              webcamStatus.textContent = 'Failed to connect';
              webcamStatus.style.color = '#d32f2f';
            }
          }, 5000);
        } else {
          // Stop webcam streaming
          toggleWebcamBtn.textContent = 'Start Feed';
          
          // Send command to stop webcam
          socket.emit('tree-command', {
            type: 'webcam-control',
            action: 'stop'
          });
          
          // Update UI
          webcamActive = false;
          webcamDisplay.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
          webcamOverlay.style.display = 'flex';
          webcamOverlay.textContent = 'Webcam feed stopped';
          webcamStatus.textContent = 'Stopped';
          webcamStatus.style.color = '#666';
        }
      }
    });
    
    // Refresh webcam button
    refreshWebcamBtn.addEventListener('click', () => {
      if (socket && socket.connected) {
        // Reset UI
        webcamActive = false;
        webcamDisplay.src = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
        webcamOverlay.style.display = 'flex';
        webcamOverlay.textContent = 'Requesting webcam feed...';
        webcamStatus.textContent = 'Refreshing...';
        webcamStatus.style.color = '#666';
        
        // Request a fresh frame
        socket.emit('tree-command', {
          type: 'webcam-refresh'
        });
        
        // Set a timeout to check if we received a new frame
        setTimeout(() => {
          if (!webcamActive) {
            webcamOverlay.textContent = 'Webcam feed unavailable';
            webcamStatus.textContent = 'Failed to connect';
            webcamStatus.style.color = '#d32f2f';
          }
        }, 5000);
      }
    });
    
    // Check if frames are stale
    function checkFrameFreshness() {
      const now = Date.now();
      const freshnessDuration = 10000; // 10 seconds
      
      // Only check for stale frames if we're supposed to be streaming
      if (webcamActive && now - lastFrameTimestamp > freshnessDuration) {
      // if (webcamStreamingEnabled && webcamActive && now - lastFrameTimestamp > freshnessDuration) {
        // Frame is stale
        webcamActive = false;
        webcamOverlay.style.display = 'flex';
        webcamOverlay.textContent = 'Webcam feed lost';
        webcamStatus.textContent = 'Connection lost';
        webcamStatus.style.color = '#d32f2f';
      }
    }
    
    // Check frame freshness periodically
    setInterval(checkFrameFreshness, 5000);
    
    // Gate 1 toggle button
    toggleGateBtn.addEventListener('click', async () => {
      // Toggle gate state
      gateOpen = !gateOpen;
      
      // Update button appearance
      if (gateOpen) {
        toggleGateBtn.textContent = 'Close Gate';
        toggleGateBtn.style.backgroundColor = '#e53935'; // Red
      } else {
        toggleGateBtn.textContent = 'Open Gate';
        toggleGateBtn.style.backgroundColor = '#ff9800'; // Orange
      }
      
      // Disable button during request
      toggleGateBtn.disabled = true;
      
      try {
        // Set the angle based on gate state
        const angle = gateOpen ? 180 : 0;
        
        // Make API request to servo controller
        const url = 'http://192.168.1.40/servo';
        const options = {
          method: 'POST',
          headers: {'content-type': 'application/json'},
          body: JSON.stringify({ angle })
        };
        
        console.log(`Sending request to ${url} with angle: ${angle}`);
        
        const response = await fetch(url, options);
        const data = await response.json();
        console.log('Server response:', data);
        
      } catch (error) {
        console.error('Error controlling gate:', error);
        // Show error state
        toggleGateBtn.style.opacity = '0.7';
      } finally {
        // Re-enable button
        toggleGateBtn.disabled = false;
      }
    });
    
    // Gate 2 toggle button
    toggleGate2Btn.addEventListener('click', async () => {
      // Toggle gate state
      gate2Open = !gate2Open;
      
      // Update button appearance
      if (gate2Open) {
        toggleGate2Btn.textContent = 'Close Gate 2';
        toggleGate2Btn.style.backgroundColor = '#1565C0'; // Darker blue
      } else {
        toggleGate2Btn.textContent = 'Open Gate 2';
        toggleGate2Btn.style.backgroundColor = '#2196F3'; // Blue
      }
      
      // Disable button during request
      toggleGate2Btn.disabled = true;
      
      try {
        // Set the action based on gate state
        const action = gate2Open ? 'open' : 'close';
        
        // Make API request to motor controller
        const url = 'http://192.168.1.40/motor';
        const options = {
          method: 'POST',
          headers: {'content-type': 'application/json'},
          body: JSON.stringify({ action })
        };
        
        console.log(`Sending request to ${url} with action: ${action}`);
        
        const response = await fetch(url, options);
        const data = await response.json();
        console.log('Gate 2 server response:', data);
        
      } catch (error) {
        console.error('Error controlling gate 2:', error);
        // Show error state
        toggleGate2Btn.style.opacity = '0.7';
      } finally {
        // Re-enable button
        toggleGate2Btn.disabled = false;
      }
    });
    
    // Initialize
    connectSocket();
  </script>
</body>
</html>